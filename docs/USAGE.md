# üìö Usage Guide

Comprehensive guide to using the Deep Research Agent.

## Basic Usage

### Via Streamlit UI

1. **Start the UI:**
```bash
streamlit run frontend/app.py
```

2. **Enter your query:**
   - Type a research question in the input box
   - Or click one of the example queries
   - Click "Start Research"

3. **View results:**
   - Research report with synthesis
   - Citations and sources
   - Metadata about the search

### Via FastAPI

1. **Start the API:**
```bash
uvicorn backend.api.main:app --reload
```

2. **Make a request:**
```bash
curl -X POST "http://localhost:8000/research" \
  -H "Content-Type: application/json" \
  -d '{"query": "What are microservices best practices?"}'
```

3. **Response format:**
```json
{
  "query": "What are microservices best practices?",
  "report": "Comprehensive synthesized report here...",
  "metadata": {
    "sources_used": ["github", "hackernews"],
    "max_results_per_source": 5
  }
}
```

### Via Python

```python
import asyncio
from backend.agent import ResearchAgent
from backend.sources import initialize_sources

async def main():
    # Initialize
    initialize_sources()
    agent = ResearchAgent()
    
    # Research
    result = await agent.research(
        "What are the trade-offs of microservices vs monoliths?"
    )
    
    print(result)

asyncio.run(main())
```

## Example Queries

### Software Architecture
```
- "Compare microservices vs monolithic architecture"
- "Best practices for API design in 2024"
- "When to use event-driven architecture"
```

### Programming Languages
```
- "Is Rust worth learning for web development?"
- "Python vs Go for backend services"
- "TypeScript benefits and drawbacks"
```

### Frameworks & Libraries
```
- "Compare Next.js vs Remix for React applications"
- "Best state management for React in 2024"
- "FastAPI vs Flask for Python APIs"
```

### Tools & Technologies
```
- "Docker vs Kubernetes for small teams"
- "PostgreSQL vs MongoDB for SaaS applications"
- "GitHub Actions vs GitLab CI/CD"
```

## API Endpoints

### POST /research
Full research with synthesis.

**Request:**
```json
{
  "query": "string",
  "max_results_per_source": 5  // optional
}
```

**Response:**
```json
{
  "query": "string",
  "report": "string",
  "metadata": {}
}
```

### POST /research/quick
Quick search without synthesis (faster).

**Request:**
```json
{
  "query": "string",
  "max_results_per_source": 5
}
```

**Response:**
```json
{
  "query": "string",
  "total_results": 10,
  "sources": ["github", "hackernews"],
  "results": {
    "github": [...],
    "hackernews": [...]
  }
}
```

### GET /sources
List available sources and their status.

**Response:**
```json
{
  "sources": [
    {
      "source": "github",
      "available": true,
      "status": "ok"
    },
    {
      "source": "hackernews",
      "available": true,
      "status": "ok"
    }
  ],
  "total": 2,
  "available": 2
}
```

### GET /health
Health check endpoint.

## Advanced Usage

### Custom Agent Configuration

```python
from langchain_groq import ChatGroq
from deepagents import create_deep_agent
from backend.sources import source_registry

# Custom LLM
custom_llm = ChatGroq(
    model_name="llama-3.1-70b-versatile",
    temperature=0.5,  # More conservative
    max_tokens=4000,
)

# Create custom agent
agent = create_deep_agent(
    model=custom_llm,
    tools=[...],  # Your custom tools
    system_prompt="Custom instructions..."
)
```

### Batch Research

```python
queries = [
    "React best practices",
    "Vue.js vs React",
    "Angular 2024 updates"
]

async def batch_research():
    agent = ResearchAgent()
    results = []
    
    for query in queries:
        result = await agent.research(query)
        results.append({
            "query": query,
            "report": result
        })
    
    return results

results = asyncio.run(batch_research())
```

### Export Results

```python
import json
from datetime import datetime

# Research
result = await agent.research(query)

# Export to JSON
output = {
    "query": query,
    "report": result,
    "timestamp": datetime.now().isoformat(),
    "metadata": {...}
}

with open("research_report.json", "w") as f:
    json.dump(output, f, indent=2)
```

### Export to Markdown

```python
# Research
result = await agent.research(query)

# Create markdown
markdown = f"""# Research Report

**Query:** {query}
**Date:** {datetime.now().strftime("%Y-%m-%d")}

---

{result}

---

*Generated by Deep Research Agent*
"""

with open("research_report.md", "w") as f:
    f.write(markdown)
```

## Best Practices

### Writing Good Queries

‚úÖ **Good:**
```
"Compare Redux vs Zustand for React state management"
"What are the benefits of using Rust for system programming?"
"Best practices for securing REST APIs"
```

‚ùå **Too Vague:**
```
"Tell me about React"
"What is programming?"
"Software"
```

### Query Tips

1. **Be Specific:** Include context and constraints
   - Instead of: "Best database"
   - Use: "Best database for a real-time chat application"

2. **Ask Comparisons:** Get multiple perspectives
   - "Compare X vs Y for [use case]"

3. **Request Best Practices:** Get actionable advice
   - "Best practices for [technology/topic]"

4. **Specify Time:** For evolving topics
   - "Latest React patterns in 2024"

## Performance Tips

### Faster Responses
- Use `/research/quick` for raw results
- Reduce `max_results_per_source`
- Cache frequently asked queries

### Better Quality
- Use more specific queries
- Include technical terms
- Specify the domain/context

## Troubleshooting

### Slow Responses
- Check internet connection
- Verify API rate limits aren't hit
- Try reducing max_results_per_source

### Poor Quality Results
- Make query more specific
- Include technical context
- Try different phrasings

### Missing Sources
- Check source availability: `GET /sources`
- Verify API keys in `.env`
- Check source-specific rate limits

## Examples by Use Case

### Learning New Technology
```
Query: "Is Rust worth learning for web development in 2024?"

Agent will:
- Search GitHub for popular Rust web projects
- Find HN discussions about Rust adoption
- Synthesize: ecosystem maturity, job market, learning curve
```

### Making Architecture Decisions
```
Query: "Microservices vs monolith for a startup with 5 engineers"

Agent will:
- Search for real-world experiences
- Find discussions on team size implications
- Synthesize: trade-offs, complexity, scalability
```

### Staying Updated
```
Query: "What's new in React 19?"

Agent will:
- Find latest GitHub releases and RFCs
- Search HN for community reactions
- Synthesize: new features, breaking changes, adoption
```

---

**Need more help?** Check [FAQ.md](FAQ.md) or open an issue!
